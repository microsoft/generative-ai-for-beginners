# 프롬프트 엔지니어링 기초

[![Prompt Engineering Fundamentals](../../images/04-lesson-banner.png?WT.mc_id=academic-105485-koreyst)](https://aka.ms/gen-ai-lesson4-gh?WT.mc_id=academic-105485-koreyst)

LLM에게 어떻게 프롬프트를 작성하는지는 중요합니다. 신중하게 작성된 프롬프트는 그렇지 않은 프롬프트보다 더 좋은 결과를 얻을 수 있습니다. 그런데 이런 개념들, 프롬프트, 프롬프트 엔지니어링이 무엇인지, 그리고 LLM에게 보내는 것을 어떻게 개선할 수 있는지에 대한 질문들은 바로 이 장과 다가올 장에서 답변하려고 합니다.

_생성형 AI_ 는 사용자의 요청에 응답하여 새로운 콘텐츠(예: 텍스트, 이미지, 오디오, 코드 등)를 생성할 수 있는 능력을 가지고 있습니다. 이는 OpenAI의 GPT("Generative Pre-trained Transformer") 시리즈와 같은 _대형 언어 모델_ (LLMs)을 사용하여 자연어와 코드를 통해 이를 달성합니다.

사용자들은 이제 채팅과 같은 친숙한 패러다임을 사용하여 이러한 모델과 상호작용할 수 있으며, 기술적 전문지식이나 훈련 없이도 이를 사용할 수 있습니다. 이 모델들은 _프롬프트 기반_ 입니다 - 사용자들은 텍스트 입력(프롬프트, prompt)을 보내고 AI의 응답(완성, completion)을 받습니다. 그런 다음 사용자들은 다중 턴 대화에서 반복적으로 "AI와 대화"를 할 수 있으며, 응답이 그들의 기대에 부합할 때까지 프롬프트를 정제할 수 있습니다.

"프롬프트"는 이제 생성형 AI 앱의 주요 _프로그래밍 인터페이스_ 가 되어, 모델에게 무엇을 해야 하는지 알려주고 반환된 응답의 품질에 영향을 미칩니다. "프롬프트 엔지니어링"은 프롬프트의 _디자인과 최적화_ 에 초점을 맞춘 빠르게 성장하는 연구 분야로, 대규모로 일관성 있고 품질 좋은 응답을 제공합니다.

## 학습 목표

이번 강의에서는 프롬프트 엔지니어링이 무엇인지, 왜 중요한지, 그리고 주어진 모델과 애플리케이션 목표에 대해 더 효과적인 프롬프트를 어떻게 작성할 수 있는지에 대해 배웁니다. 프롬프트 엔지니어링에 대한 핵심 개념과 모범 사례를 이해하고, 이러한 개념들이 실제 예제에 적용되는 것을 볼 수 있는 인터랙티브한 Jupyter 노트북 "샌드박스" 환경에 대해 알아봅니다.

이번 강의가 끝날 즈음에는 우리는 다음과 같은 내용들을 할 수 있게 될 것입니다:

1. 프롬프트 엔지니어링이 무엇인지 그리고 왜 중요한지 설명할 수 있습니다.
2. 프롬프트의 구성 요소들을 설명하고 어떻게 사용하는지 알 수 있습니다.
3. 프롬프트 엔지니어링에 대한 모범 사례와 기법들을 배울 수 있습니다.
4. 배운 기법들을 OpenAI 엔드포인트를 이용해 실제 예제에 적용할 수 있습니다.

## 샌드박스 학습하기

현재 프롬프트 엔지니어링은 과학보다는 예술에 가깝습니다. 이에 대한 직관을 향상시키는 가장 좋은 방법은 _더 많이 연습하는 것_ 이며, 응용 분야 전문 지식과 결합하여 추천 기법과 모델에 특화된 최적화를 시행착오(trial-and-error)하는 것입니다.

이번 수업에 따른 Jupyter 노트북은 배운 내용을 시도해볼 수 있는 _샌드박스_ 환경을 제공합니다. 여기서는 각 단계에서 또는 마지막의 코드 도전 과제에서 배운 것을 시도해볼 수 있습니다. 연습문제를 실행하려면 다음이 필요합니다:

1. Azure OpenAI API 키 - 배포된 LLM의 서비스 엔드포인트입니다.
2. 파이썬 런타임 - 노트북을 실행할 수 있는 환경입니다.

이 저장소는 Python 3 런타임이 포함된 _dev 컨테이너_ 로 구성되어 있습니다. GitHub 코드스페이스에서 저장소를 열거나 로컬 Docker 데스크톱에서 열면 런타임이 자동으로 활성화됩니다. 그런 다음 노트북을 열고 Python 3.x 커널을 선택하여 노트북을 실행 준비합니다.

기본 노트북은 Azure OpenAI 서비스 리소스와 함께 사용하도록 설정되어 있습니다. 폴더의 루트에 있는 `.env.copy` 파일을 `.env`로 복사하고 `AZURE_OPENAI_API_KEY=` 및 `AZURE_OPENAI_API_ENDPOINT=` 줄에 API 키와 엔드포인트를 업데이트하면 됩니다.  
[Azure 포털](https://portal.azure.com?WT.mc_id=academic-105485-koreyst)에서 자신의 Azure OpenAI 리소스로 이동한 후 왼쪽 메뉴의 _Keys and Endpoints_ 탭을 열어 자신의 자격증명을 확인할 수 있습니다.
또한, 배포를 생성할 때 할당한 모델의 이름을 `AZURE_OPENAI_DEPLOYMENT` 변수에 추가해 주세요. 이 연습에 추천하는 모델은 'gpt-35-turbo'입니다.

노트북에는 _starter_ 연습문제가 포함되어 있지만, 더 많은 예제나 아이디어를 시도해보고 프롬프트 디자인에 대한 직관력을 키우기 위해 자신만의 _마크다운_ (설명) 및 _코드_ (프롬프트 요청) 섹션을 추가하는 것이 좋습니다.

## 우리 스타트업

이제, _본 주제_ 가 우리 스타트업의 [교육에 AI 혁신을 가져오기](https://educationblog.microsoft.com/2023/06/collaborating-to-bring-ai-innovation-to-education?WT.mc_id=academic-105485-koreyst) 미션과 어떻게 관련되는지에 대해 이야기해보겠습니다. 우리는 _개인화된 학습_ (personalized learning)의 AI 기반 응용 프로그램을 구축하고자 합니다. 그러니 애플리케이션 목표와 모델에 대한 다양한 사용자들이 프롬프트를 "디자인" 할 수 있는 방법에 대해 생각해보겠습니다:

- **관리자** 는 AI가 _커리큘럼 데이터를 분석하여 부족한 부분을 식별_ 하도록 요청할 수 있습니다. AI는 결과를 요약하거나 코드로 시각화할 수 있습니다.
- **교육자** 는 _대상 그룹과 주제에 대한 레슨 계획을 생성_ 하도록 AI에게 요청할 수 있습니다. AI는 지정된 형식으로 개인화된 계획을 작성할 수 있습니다.
- **학생** 들은 _어려운 주제를 가르쳐 달라고 AI에게 요청_ 할 수 있습니다. 이제 AI는 학생의 수준에 맞게 수업, 힌트 및 예제를 안내할 수 있습니다.

이것은 빙산의 일각에 불과합니다. [Prompts For Education](https://github.com/microsoft/prompts-for-edu/tree/main?WT.mc_id=academic-105485-koreyst)를 확인해보세요 - 교육 전문가들이 선별한 오픈 소스 프롬프트 라이브러리로, 더 다양한 가능성을 알 수 있습니다! _샌드박스에서 이러한 프롬프트 중 일부를 실행하거나 OpenAI Playground를 사용하여 결과를 확인해보세요!_

<!--
LESSON TEMPLATE:
This unit should cover core concept #1.
Reinforce the concept with examples and references.

CONCEPT #1:
Prompt Engineering.
Define it and explain why it is needed.
-->

## 프롬프트 엔지니어링이란 무엇인가요?

이 레슨에서는 **프롬프트 엔지니어링**을 주어진 애플리케이션 목표와 모델에 대해 일관되고 품질 좋은 응답을 제공하기 위해 텍스트 입력(프롬프트)를 _디자인하고 최적화하는_ 과정으로 정의했습니다. 이는 2단계 프로세스로 생각할 수 있습니다:

- 주어진 모델과 목표에 대한 초기 프롬프트를 _디자인_ 하는 것
- 응답의 품질을 향상시키기 위해 프롬프트를 _반복적으로 개선_ 하는 것

이는 최적의 결과를 얻기 위해 사용자의 직관과 노력이 필요한 시행착오적인 과정입니다. 그렇다면 왜 중요한 것일까요? 이 질문에 답하기 위해서는 세 가지 개념을 먼저 이해해야 합니다:

- _토큰화_ = 모델이 프롬프트를 "보는" 방식
- _Base LLMs_ = 파운데이션 모델이 프롬프트를 "처리"하는 방식
- _Instruction-Tuned LLMs_ = 모델이 "작업"을 인식하는 방식

### 토큰화

LLM은 프롬프트를 _토큰들의 시퀀스_ 로 인식하며, 다른 모델(또는 모델의 버전)은 동일한 프롬프트를 다른 방식으로 토큰화할 수 있습니다. LLM은 토큰에 대해 훈련되기 때문에(원시 텍스트가 아닌) 프롬프트의 토큰화 방식은 생성된 응답의 품질에 직접적인 영향을 미칩니다.

토큰화가 어떻게 작동하는지 직관을 얻기 위해 아래와 같은 [OpenAI Tokenizer](https://platform.openai.com/tokenizer?WT.mc_id=academic-105485-koreyst)와 같은 도구를 사용해보세요. 프롬프트를 복사하여 붙여넣고, 공백 문자와 구두점이 어떻게 처리되는지 주의깊게 살펴보세요. 이 예시는 오래된 LLM(GPT-3)을 보여주므로, 새로운 모델로 시도하면 다른 결과가 나올 수 있습니다.

![토큰화](../../images/04-tokenizer-example.png?WT.mc_id=academic-105485-koreyst)

### 개념: Foundation 모델

프롬프트가 토큰화되면, ["Base LLM"](https://blog.gopenai.com/an-introduction-to-base-and-instruction-tuned-large-language-models-8de102c785a6?WT.mc_id=academic-105485-koreyst) (또는 Foundation 모델)의 주요 기능은 해당 시퀀스에서 토큰을 예측하는 것입니다. LLM은 대량의 텍스트 데이터셋으로 훈련되었기 때문에 토큰 간의 통계적 관계에 대한 좋은 감각을 가지고 있으며, 이 예측을 어느 정도의 확신으로 수행할 수 있습니다. 그러나 LLM은 프롬프트나 토큰의 "의미"를 이해하지 않습니다. 그들은 그들의 다음 예측으로 "완성"할 수 있는 패턴만을 볼 뿐입니다. 사용자의 개입이나 미리 설정된 조건에 의해 종료될 때까지 시퀀스를 계속 예측할 수 있습니다.

프롬프트 기반 완성이 어떻게 작동하는지 보고 싶으신가요? 위의 프롬프트를 Azure OpenAI Studio의 [_Chat Playground_](https://oai.azure.com/playground?WT.mc_id=academic-105485-koreyst)에 입력하고 기본 설정으로 실행해보세요. 시스템은 프롬프트를 정보 요청으로 처리하도록 구성되어 있으므로 이와 관련된 완성을 볼 수 있을 것입니다.

하지만 사용자가 특정한 기준이나 작업 목표를 충족하는 내용을 보고 싶어한다면 어떻게 해야 할까요? 이때 _instruction-tuned_ LLM이 등장합니다.

![Base LLM Chat Completion](../../images/04-playground-chat-base.png?WT.mc_id=academic-105485-koreyst)

### 개념: Instruction Tuned LLMs

[Instruction Tuned LLM](https://blog.gopenai.com/an-introduction-to-base-and-instruction-tuned-large-language-models-8de102c785a6?WT.mc_id=academic-105485-koreyst)은 Foundation 모델로 시작하여 예제나 입력/출력 쌍(예: 다중 턴 "메시지")로 세밀하게 튜닝되며, 명확한 지시사항을 포함할 수 있으며, AI의 응답은 해당 지시를 따르도록 시도합니다.

이는 Reinforcement Learning with Human Feedback (RLHF)와 같은 기법을 사용하여 모델이 _지시를 따르고_ _피드백을 통해 학습_ 하여 실제 응용 프로그램에 더 적합하고 사용자의 목표와 관련성이 더 높은 응답을 생성할 수 있도록 합니다.

이제 이를 시도해보세요 - 위의 프롬프트를 다시 방문하되, _시스템 메시지_ 를 다음과 같은 지시사항으로 변경하여 실행해보세요:

> _제공된 내용을 초등학교 2학년 학생을 위해 요약해주세요. 3-5개의 항목으로 이루어진 한 단락으로 결과를 유지하세요._

결과가 원하는 목표와 형식을 반영하도록 조정된 것을 보실 수 있나요? 교육자는 이제 이 응답을 해당 수업의 슬라이드에 직접 사용할 수 있습니다.

![Instruction Tuned LLM Chat Completion](../../images/04-playground-chat-instructions.png?WT.mc_id=academic-105485-koreyst)

## 왜 프롬프트 엔지니어링이 필요한가요?

이제 LLM이 프롬프트를 처리하는 방식을 알았으니, _왜_ 프롬프트 엔지니어링이 필요한지 이야기해봅시다. 답은 현재의 LLM이 _신뢰할 수 있고 일관된 완성_ 을 얻기 위해서는 프롬프트 구성과 최적화에 노력을 기울여야 하는 여러 가지 도전 과제를 가지고 있다는 사실에 있습니다. 예를 들어:

1. **모델 응답은 확률적입니다.** _동일한 프롬프트_ 는 다른 모델이나 모델 버전에서 다른 응답을 생성할 가능성이 높습니다. 또한 _동일한 모델_ 에서도 _다른 시간에_ 다른 결과를 생성할 수 있습니다. _프롬프트 엔지니어링 기법은 더 나은 가드레일을 제공하여 이러한 변동을 최소화하는 데 도움을 줄 수 있습니다._

2. **모델은 응답을 가짜로 만들 수 있습니다.** 모델은 _대규모이지만 유한한_ 데이터셋으로 사전 훈련되기 때문에 훈련 범위를 벗어난 개념에 대한 지식이 부족합니다. 결과적으로, 모델은 정확하지 않거나 상상력이 풍부하거나 알려진 사실과 직접적으로 모순되는 완성을 생성할 수 있습니다. _프롬프트 엔지니어링 기법은 AI에게 인용문이나 추론을 요청함으로써 이러한 가짜 응답을 식별하고 완화하는 데 도움을 줄 수 있습니다._

3. **모델의 능력은 다양할 수 있습니다.** 새로운 모델이나 모델 세대는 더 풍부한 기능을 가지지만, 비용과 복잡성에서 독특한 특징과 트레이드 오프를 가져올 수도 있습니다. _프롬프트 엔지니어링은 차이를 추상화하고 모델별 요구 사항에 맞게 조정하는 최상의 방법과 워크플로우를 개발하는 데 도움을 줄 수 있습니다._

OpenAI 또는 Azure OpenAI Playground에서 이를 실제로 확인해보세요:

- 동일한 프롬프트를 다른 LLM 배포(예: OpenAI, Azure OpenAI, Hugging Face)와 함께 사용해보세요 - 변화를 보셨나요?
- 동일한 프롬프트를 _동일한_ LLM 배포(예: Azure OpenAI Playground)에서 반복해서 사용해보세요 - 이러한 변화는 어떻게 다른가요?

### Fabrications 예시

이 강좌에서는 LLM이 훈련 제약이나 다른 제약으로 인해 사실적이지 않은 정보를 생성하는 현상을 가리키는 **"fabrication"** 이라는 용어를 사용합니다. 일반적인 기사나 연구 논문에서는 이를 _"환각(hallucination)"_ 이라고 부르기도 합니다. 그러나 우리는 기계적으로 생성된 결과에 인간과 유사한 특성을 부여하는 것을 방지하기 위해 _"fabrication"_ 이라는 용어를 사용하는 것을 강력히 권장합니다. 이는 또한 용어 관점에서 [책임 있는 AI 가이드라인](https://www.microsoft.com/ai/responsible-ai?WT.mc_id=academic-105485-koreyst)을 강화하며, 일부 상황에서 논란이 될 수 있는 모욕적이거나 포용되지 않는 용어를 제거합니다.

fabrication이 어떻게 작동하는지 알아보고 싶으신가요? 훈련 데이터셋에서 찾을 수 없는 존재하지 않는 주제에 대한 내용을 AI에게 생성하도록 지시하는 프롬프트를 생각해보세요. 예를 들어 - 저는 다음과 같은 프롬프트를 시도해보았습니다:

> **프롬프트:** 2076년의 화성 전쟁에 대한 수업 계획을 생성하세요.

웹 검색을 통해 2076년의 화성 전쟁에 대한 허구의 설명(예: TV 시리즈나 책)이 있음을 알 수 있었습니다. 그러나 2076년은 _미래_ 이기 때문에 실제 사건과 관련될 수 없다는 상식도 우리에게 알려줍니다.

그렇다면 이 프롬프트를 다른 LLM 제공업체에서 실행하면 어떻게 될까요?

> **응답 1**: OpenAI Playground (GPT-35)

![응답 1](../../images/04-fabrication-oai.png?WT.mc_id=academic-105485-koreyst)

> **응답 2**: Azure OpenAI Playground (GPT-35)

![응답 2](../../images/04-fabrication-aoai.png?WT.mc_id=academic-105485-koreyst)

> **응답 3**: Hugging Face Chat Playground (LLama-2)

![응답 3](../../images/04-fabrication-huggingchat.png?WT.mc_id=academic-105485-koreyst)

예상대로, 각 모델(또는 모델 버전)은 확률적인 동작과 모델 능력의 차이로 인해 약간 다른 응답을 생성합니다. 예를 들어, 하나의 모델은 8학년 학생을 대상으로 하고 다른 모델은 고등학생을 가정합니다. 그러나 세 모델 모두 미지식 사용자를 설득할 수 있는 실제 사건인 것처럼 보이는 응답을 생성했습니다.

_메타프롬프팅(meta-prompting)_ 과 _temperature 설정_ 과 같은 프롬프트 엔지니어링 기법은 일부 fabrication을 줄일 수 있습니다. 새로운 프롬프트 엔지니어링 _아키텍처_ 는 이러한 효과를 완화하거나 줄이기 위해 새로운 도구와 기법을 프롬프트 플로우에 매끄럽게 통합합니다.

## 사례 연구: GitHub Copilot

이 섹션을 마무리하기 전에, 실제 세계 솔루션에서 프롬프트 엔지니어링이 어떻게 사용되는지 알아보기 위해 한 가지 사례 연구인 [GitHub Copilot](https://github.com/features/copilot?WT.mc_id=academic-105485-koreyst)을 살펴봅시다.

GitHub Copilot은 "AI 동료 프로그래머"로, 텍스트 프롬프트를 코드 완성으로 변환하며 개발 환경(예: Visual Studio Code)에 통합되어 원활한 사용자 경험을 제공합니다. 아래의 블로그 시리즈에서 문서화된 바와 같이, 초기 버전은 OpenAI Codex 모델을 기반으로 하였으며, 엔지니어들은 빠르게 모델을 세밀하게 튜닝하고 프롬프트 엔지니어링 기법을 개발하여 코드 품질을 개선해야 함을 깨달았습니다. 7월에는 [더 빠른 제안을 위해 Codex를 넘어선 개선된 AI 모델을 선보였습니다](https://github.blog/2023-07-28-smarter-more-efficient-coding-github-copilot-goes-beyond-codex-with-improved-ai-model/?WT.mc_id=academic-105485-koreyst).

학습 과정을 따라가기 위해 게시물을 순서대로 읽어보세요.

- **2023년 5월** | [GitHub Copilot이 코드 이해 능력을 향상시키는 방법](https://github.blog/2023-05-17-how-github-copilot-is-getting-better-at-understanding-your-code/?WT.mc_id=academic-105485-koreyst)
- **2023년 5월** | [GitHub Copilot 뒤의 LLMs와의 작업](https://github.blog/2023-05-17-inside-github-working-with-the-llms-behind-github-copilot/?WT.mc_id=academic-105485-koreyst).
- **2023년 6월** | [GitHub Copilot을 위한 더 나은 프롬프트 작성 방법](https://github.blog/2023-06-20-how-to-write-better-prompts-for-github-copilot/?WT.mc_id=academic-105485-koreyst).
- **2023년 7월** | [.. GitHub Copilot이 개선된 AI 모델로 Codex를 넘어섭니다](https://github.blog/2023-07-28-smarter-more-efficient-coding-github-copilot-goes-beyond-codex-with-improved-ai-model/?WT.mc_id=academic-105485-koreyst)
- **2023년 7월** | [프롬프트 엔지니어링과 LLM에 대한 개발자 가이드](https://github.blog/2023-07-17-prompt-engineering-guide-generative-ai-llms/?WT.mc_id=academic-105485-koreyst)
- **2023년 9월** | [GitHub Copilot에서 배운 기업용 LLM 앱 개발 방법](https://github.blog/2023-09-06-how-to-build-an-enterprise-llm-application-lessons-from-github-copilot/?WT.mc_id=academic-105485-koreyst)

더 많은 예시와 기법이 실제 세계 응용 프로그램에 적용되는 방법을 보여주는 [이 게시물](https://github.blog/2023-09-27-how-i-used-github-copilot-chat-to-build-a-reactjs-gallery-prototype/?WT.mc_id=academic-105485-koreyst)과 같은 게시물을 찾아보기 위해 [Engineering 블로그](https://github.blog/category/engineering/?WT.mc_id=academic-105485-koreyst)를 참조할 수도 있습니다.

---

<!--
LESSON TEMPLATE:
This unit should cover core concept #2.
Reinforce the concept with examples and references.

CONCEPT #2:
Prompt Design.
Illustrated with examples.
-->

## 프롬프트 구성

프롬프트 엔지니어링이 왜 중요한지 알아보았으니, 이제 프롬프트가 어떻게 _구성_ 되는지 이해하고 더 효과적인 프롬프트 디자인을 위한 다양한 기법을 평가해보겠습니다.

### 기본 프롬프트

먼저 기본 프롬프트부터 시작해보겠습니다. 이는 다른 맥락 없이 모델에게 보내지는 텍스트 입력입니다. 예를 들어, OpenAI [Completion API](https://platform.openai.com/docs/api-reference/completions?WT.mc_id=academic-105485-koreyst)에 미국 국가 애국가의 처음 몇 단어를 보내면 모델은 즉시 다음 몇 줄을 포함한 응답을 _완성_ 합니다. 이는 기본적인 예측 동작을 보여줍니다.

| 프롬프트 (입력)    | 완성 (출력)                                                                                         |
| :----------------- | :-------------------------------------------------------------------------------------------------- |
| Oh say can you see | "The Star-Spangled Banner"라는 미국의 국가 애국가 가사를 시작하고 있는 것 같습니다. 전체 가사는 ... |

### 복잡한 프롬프트

이제 그 기본 프롬프트에 맥락과 지침을 추가해보겠습니다. [Chat Completion API](https://learn.microsoft.com/azure/ai-services/openai/how-to/chatgpt?WT.mc_id=academic-105485-koreyst)를 사용하면 _사용자_ 입력과 _어시스턴트_ 응답을 반영하는 입력/출력 쌍과 어시스턴트의 동작이나 성격을 설정하는 시스템 메시지로 구성된 복잡한 프롬프트를 만들 수 있습니다.

아래의 요청은 _토큰화_ 를 통해 맥락과 대화에서 관련 정보를 효과적으로 포착합니다. 이제 시스템 맥락을 변경하는 것은 사용자 입력과 마찬가지로 완성 품질에 큰 영향을 미칠 수 있습니다.

```python
response = openai.chat.completions.create(
    model="gpt-3.5-turbo",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Who won the world series in 2020?"},
        {"role": "assistant", "content": "The Los Angeles Dodgers won the World Series in 2020."},
        {"role": "user", "content": "Where was it played?"}
    ]
)
```

### 지시 프롬프트 (Instruction Prompt)

위의 예시에서 사용자 프롬프트는 정보 요청으로 해석될 수 있는 간단한 텍스트 쿼리였습니다. _지시_ 프롬프트를 사용하면 해당 텍스트를 사용하여 AI에게 더 자세한 작업을 지정하여 더 나은 안내를 제공할 수 있습니다. 다음은 예시입니다:

| 프롬프트 (입력)                                                                                                                                                                                                     | 완성 (출력)                                                                                                            | 지시 유형         |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------- | :---------------- |
| 시민 전쟁에 대한 설명을 작성하세요.                                                                                                                                                                                 | _간단한 단락을 반환합니다._                                                                                            | 간단한            |
| 시민 전쟁에 대한 설명을 작성하세요. 주요 날짜와 사건을 제공하고 그들의 의미를 설명하세요.                                                                                                                           | _단락 다음에 주요 사건 날짜와 설명이 포함된 목록을 반환합니다._                                                        | 복잡한            |
| 시민 전쟁에 대한 설명을 1단락으로 작성하세요. 주요 날짜와 그들의 의미를 가진 3개의 불릿 포인트를 제공하세요. 또한 주요 역사 인물과 그들의 기여를 가진 3개의 불릿 포인트를 제공하세요. 결과를 JSON 파일로 반환하세요 | _텍스트 상자에 더 많은 세부 정보를 JSON 형식으로 반환합니다. 파일로 복사하여 필요에 따라 유효성을 검사할 수 있습니다._ | 복잡한. 형식화됨. |

## 주요 콘텐츠 (Primary Content)

위의 예시에서 프롬프트는 여전히 상당히 개방적이어서 LLM이 사전 훈련된 데이터셋 중 어떤 부분이 관련 있는지를 결정할 수 있었습니다. _주요 콘텐츠(primary)_ 디자인 패턴을 사용하면 입력 텍스트를 두 부분으로 나눌 수 있습니다:

- 지시사항 (동작)
- 관련 콘텐츠 (동작에 영향을 주는)

다음은 "이를 2문장으로 요약하세요"라는 지시사항이 있는 예시입니다.

| 프롬프트 (입력)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 완성 (출력)                                                                                                                                                            |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 주피터는 태양으로부터 다섯 번째 행성이며 태양계에서 가장 큰 행성입니다. 이는 태양의 천분의 일 질량을 가진 가스 행성으로, 태양계의 다른 행성들의 질량의 2.5배입니다. 주피터는 밤하늘에서 맨 눈으로 볼 수 있는 가장 밝은 물체 중 하나이며, 기록된 역사 이전부터 고대 문명에 알려져 있습니다. 이는 로마 신 주피터에게 이름을 따왔습니다. 지구에서 볼 때, 주피터는 반사된 빛이 가시적인 그림자를 만들 정도로 충분히 밝으며, 달과 금성 이후 밤하늘에서 평균적으로 세 번째로 밝은 천체입니다. <br/> **이를 2문장으로 요약하세요** | 주피터는 태양계에서 가장 큰 행성으로 밤하늘에서 가장 밝은 물체 중 하나입니다. 로마 신 주피터에게 이름을 따온 이 가스 행성은 태양계의 다른 행성들의 질량의 2.5배입니다. |

주요 콘텐츠 세그먼트는 더 효과적인 지시사항을 만들기 위해 다양한 방법으로 사용될 수 있습니다:

- **예시** - 명시적인 지시사항으로 모델에게 무엇을 해야 하는지 알려주는 대신, 원하는 출력의 예시를 제공하고 패턴을 추론하게 합니다.
- **단서** - 지시사항 뒤에 "단서"를 추가하여 완성을 사전에 준비하고 모델을 더 관련성 높은 응답으로 이끌 수 있습니다.
- **템플릿** - 이는 플레이스홀더(변수)가 있는 프롬프트를 위한 반복 가능한 '레시피'로, 특정 사용 사례에 맞게 데이터로 사용자 정의할 수 있습니다.

이를 실제로 살펴보겠습니다.

### 예시 사용

이는 주요 콘텐츠를 사용하여 지시사항에 대한 원하는 출력의 몇 가지 예시를 모델에게 "전달"하는 접근 방식입니다. 제공된 예시의 수에 따라 제로-샷 (zero-shot)프롬프팅, 원-샷(one-shot) 프롬프팅, 퓨-샷(few-shot) 프롬프팅 등이 가능합니다.

프롬프트는 이제 세 가지 구성 요소로 이루어집니다:

- 작업 설명
- 원하는 출력의 몇 가지 예시
- 새로운 예시의 시작 (암묵적인 작업 설명이 됨)

| 학습 유형 | 프롬프트 (입력)                                                                                                                                  | 완성 (출력)                 |
| :-------- | :----------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------- |
| 제로-샷   | "The Sun is Shining". 스페인어로 번역                                                                                                            | "El Sol está brillando".    |
| 원-샷     | "The Sun is Shining" => ""El Sol está brillando". <br> "It's a Cold and Windy Day" =>                                                            | "Es un día frío y ventoso". |
| 퓨-샷     | The player ran the bases => 야구 <br/> The player hit an ace => 테니스 <br/> The player hit a six => 크리켓 <br/> The player made a slam-dunk => | 농구                        |
|           |                                                                                                                                                  |                             |

제로샷 프롬프팅에서는 명시적인 지시사항("스페인어로 번역")을 제공해야 했지만, 원샷 프롬프팅 예시에서는 추론됩니다. 퓨샷 예시는 더 많은 예시를 추가함으로써 추가 지시사항 없이 모델이 더 정확한 추론을 할 수 있는 방법을 보여줍니다.

### 프롬프트 힌트

기본 콘텐츠를 사용하는 또 다른 기법은 예시 대신 _힌트_ 를 제공하는 것입니다. 이 경우, 우리는 원하는 응답 형식을 반영하는 스니펫으로 모델을 _시작시킴_ 으로써 모델을 올바른 방향으로 이끄는 역할을 합니다. 그럼 모델은 그 힌트를 받아들여 해당 방향으로 계속 진행합니다.

| 힌트 수 | 프롬프트 (입력)                                                                                                                                                                                                                                                                                                                                        | 완성 (출력)                                                                                                                                                                                                         |
| :------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 0       | 주피터는 태양으로부터 다섯 번째 행성이며 태양계에서 가장 큰 행성입니다. 이는 태양의 천분의 일 질량을 가진 가스 행성으로, 태양계의 다른 행성들의 질량의 2.5배입니다. 주피터는 밤하늘에서 맨 눈으로 볼 수 있는 가장 밝은 물체 중 하나이며, 기록된 역사 이전부터 고대 문명에 알려져 있습니다. <br/>**이를 요약하세요**                                    | 주피터는 태양계에서 가장 큰 행성으로 밤하늘에서 가장 밝은 물체 중 하나입니다. 로마 신 주피터에게 이름을 따온 이 가스 행성은 태양계의 다른 행성들의 질량의 2.5배입니다.                                              |
| 1       | 주피터는 태양으로부터 다섯 번째 행성이며 태양계에서 가장 큰 행성입니다. 이는 태양의 천분의 일 질량을 가진 가스 행성으로, 태양계의 다른 행성들의 질량의 2.5배입니다. 주피터는 밤하늘에서 맨 눈으로 볼 수 있는 가장 밝은 물체 중 하나이며, 기록된 역사 이전부터 고대 문명에 알려져 있습니다. <br/>**이를 요약하세요** <br/> 우리가 배운 것은 주피터      | 는 태양으로부터 다섯 번째 행성이며 태양계에서 가장 큰 행성입니다. 이는 태양의 천분의 일 질량을 가진 가스 행성으로, 태양계의 다른 행성들의 질량의 2.5배입니다. 맨 눈으로 볼 수 있으며 고대 문명부터 알려져 왔습니다. |
| 2       | 주피터는 태양으로부터 다섯 번째 행성이며 태양계에서 가장 큰 행성입니다. 이는 태양의 천분의 일 질량을 가진 가스 행성으로, 태양계의 다른 행성들의 질량의 2.5배입니다. 주피터는 밤하늘에서 맨 눈으로 볼 수 있는 가장 밝은 물체 중 하나이며, 기록된 역사 이전부터 고대 문명에 알려져 있습니다. <br/>**이를 요약하세요** <br/> 우리가 배운 상위 3가지 사실: | 1. 주피터는 태양으로부터 다섯 번째 행성이며 태양계에서 가장 큰 행성입니다. <br/> 2. 이는 태양의 천분의 일 질량을 가진 가스 행성입니다...<br/> 3. 주피터는 고대부터 맨 눈으로 볼 수 있었습니다 ...                   |
|         |                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                     |

### 프롬프트 템플릿

프롬프트 템플릿은 필요에 따라 저장하고 재사용할 수 있는 *프롬프트를 위한 미리 정의된 레시피*입니다. 가장 간단한 형태에서는 [OpenAI의 예시](https://platform.openai.com/examples?WT.mc_id=academic-105485-koreyst)와 같이 상호작용 프롬프트 구성 요소(사용자 및 시스템 메시지)와 API 기반 요청 형식을 모두 제공하여 재사용을 지원합니다.

[LangChain의 예시](https://python.langchain.com/docs/modules/model_io/prompts/prompt_templates/?WT.mc_id=academic-105485-koreyst)와 같이 더 복잡한 형태에서는 _플레이스홀더_ 를 포함하여 다양한 소스(사용자 입력, 시스템 컨텍스트, 외부 데이터 소스 등)의 데이터로 교체하여 동적으로 프롬프트를 생성할 수 있습니다. 이를 통해 규모에 맞게 일관된 사용자 경험을 **프로그래밍 방식**으로 구현할 수 있는 재사용 가능한 프롬프트 라이브러리를 만들 수 있습니다.

마지막으로, 템플릿의 실제 가치는 이제 프롬프트 템플릿이 응용 프로그램별 컨텍스트나 응용 프로그램 특정 예시를 반영하여 응답을 더 관련성 있고 정확하게 만드는 _프롬프트 라이브러리_ 를 생성하고 게시할 수 있는 능력에 있습니다. [Prompts For Edu](https://github.com/microsoft/prompts-for-edu?WT.mc_id=academic-105485-koreyst) 저장소는 이 접근 방식의 훌륭한 예로, 교육 분야에 대한 프롬프트 라이브러리를 선별하여 수업 계획, 커리큘럼 설계, 학생 지도 등과 같은 주요 목표에 중점을 둡니다.

## 보조 콘텐츠

프롬프트 구성을 지시사항(작업)과 대상(주요 콘텐츠)으로 생각한다면, _보조 콘텐츠_ 는 출력을 **어떤 방식으로 영향을 주기 위해** 추가적인 컨텍스트를 제공하는 것입니다. 이는 모델이 원하는 사용자 목표나 기대에 맞게 응답을 조정하는 데 도움이 되는 튜닝 매개변수, 형식 지침, 주제 분류 등일 수 있습니다.

예를 들어: 커리큘럼의 모든 사용 가능한 과목에 대한 상세한 메타데이터(이름, 설명, 수준, 메타데이터 태그, 강사 등)가 있는 과목 카탈로그가 있다고 가정해 봅시다.

- "2023년 가을 학기 과목 카탈로그를 요약하세요"라는 지시사항을 정의할 수 있습니다.
- 원하는 출력의 몇 가지 예시를 제공하기 위해 주요 콘텐츠를 사용할 수 있습니다.
- 보조 콘텐츠를 사용하여 관심 있는 상위 5개 "태그"를 식별할 수 있습니다.

이제 모델은 몇 가지 예시에 표시된 형식으로 요약을 제공할 수 있지만, 결과에 여러 태그가 있는 경우 보조 콘텐츠에서 식별된 5개의 태그를 우선시할 수 있습니다.

---

<!--
LESSON TEMPLATE:
This unit should cover core concept #1.
Reinforce the concept with examples and references.

CONCEPT #3:
Prompt Engineering Techniques.
What are some basic techniques for prompt engineering?
Illustrate it with some exercises.
-->

## 프롬프트 엔지니어링의 모범 사례

프롬프트가 어떻게 _구성_ 될 수 있는지 알았으니, 이제 모범 사례를 반영하기 위해 어떻게 _디자인_ 할지 생각해볼 수 있습니다. 이를 두 가지로 나누어 생각해볼 수 있습니다 - 올바른 _마인드셋_ 을 가지고 적용하는 올바른 _기법_ 입니다.

### 프롬프트 엔지니어링 마인드셋

프롬프트 엔지니어링은 시행착오 과정이므로 다음과 같은 세 가지 넓은 지침 요소를 염두에 두세요:

1. **도메인 이해가 중요합니다.** 응답의 정확성과 관련성은 응용 프로그램이나 사용자가 작동하는 _도메인_ 의 함수입니다. 직관과 도메인 전문 지식을 적용하여 기법을 더욱 **맞춤화**하세요. 예를 들어, 시스템 프롬프트에서 _도메인별 특성_ 을 정의하거나 사용자 프롬프트에서 _도메인별 템플릿_ 을 사용하세요. 도메인별 컨텍스트를 반영하는 보조 콘텐츠를 제공하거나 _도메인별 단서와 예시_ 를 사용하여 모델을 익숙한 사용 패턴으로 이끌어보세요.

2. **모델 이해가 중요합니다.** 모델은 본질적으로 확률적입니다. 그러나 모델 구현은 사용하는 훈련 데이터셋(미리 훈련된 지식), 제공하는 기능(API 또는 SDK를 통해) 및 최적화된 콘텐츠 유형(코드 vs. 이미지 vs. 텍스트 등)에 따라 다를 수 있습니다. 사용하는 모델의 강점과 한계를 이해하고, 그 지식을 활용하여 작업을 _우선순위_ 를 정하거나 모델의 기능에 최적화된 _맞춤형 템플릿_ 을 구축하세요.

3. **반복과 검증이 중요합니다.** 모델은 빠르게 진화하고, 프롬프트 엔지니어링 기법도 마찬가지입니다. 도메인 전문가로서, 다른 컨텍스트나 기준이 _특정 응용 프로그램_ 에 적용되지 않을 수 있습니다. 프롬프트 엔지니어링 도구와 기법을 사용하여 프롬프트 구성을 "우선 시작"하고, 직관과 도메인 전문 지식을 활용하여 결과를 반복적으로 검증하세요. 통찰력을 기록하고, 미래의 빠른 반복을 위해 다른 사람들이 사용할 수 있는 **지식 기반**(프롬프트 라이브러리 등)을 만들어보세요.

## 모범 사례

이제 [Open AI](https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api?WT.mc_id=academic-105485-koreyst)와 [Azure OpenAI](https://learn.microsoft.com/azure/ai-services/openai/concepts/prompt-engineering#best-practices?WT.mc_id=academic-105485-koreyst) 전문가들이 권장하는 일반적인 모범 사례를 살펴보겠습니다.

| 항목                                      | 이유                                                                                                                                                                                                               |
| :---------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 최신 모델 평가하기                        | 새로운 모델 세대는 향상된 기능과 품질을 가질 가능성이 높지만, 더 높은 비용이 발생할 수도 있습니다. 영향을 평가한 후 이동 결정을 내립니다.                                                                          |
| 지시사항과 컨텍스트 분리하기              | 모델/공급자가 지시사항, 주요 콘텐츠 및 보조 콘텐츠를 명확하게 구분하기 위한 _구분자_ 를 정의하는지 확인하세요. 이는 모델이 토큰에 더 정확한 가중치를 할당할 수 있도록 도와줍니다.                                  |
| 구체적이고 명확하게 작성하기              | 원하는 컨텍스트, 결과, 길이, 형식, 스타일 등에 대해 더 많은 세부 정보를 제공하세요. 이는 응답의 품질과 일관성을 높일 것입니다. 재사용 가능한 템플릿으로 레시피를 작성하세요.                                       |
| 상세 설명과 예시 사용하기                 | 모델은 "보여주고 설명하기" 접근법에 더 잘 반응할 수 있습니다. 지시사항만 제공하는 `zero-shot` 접근법으로 시작한 다음, 원하는 출력의 몇 가지 예시를 제공하는 `few-shot`으로 세부 조정해보세요. 유추법을 사용하세요. |
| 시작 단어나 구문을 사용하여 완성 시작하기 | 응답의 시작점으로 사용할 수 있는 몇 가지 선행 단어나 구문을 제공하여 원하는 결과로 모델을 유도하세요.                                                                                                              |
| 반복하기                                  | 때로는 모델에게 반복해서 지시해야 할 수도 있습니다. 주요 콘텐츠 앞뒤로 지시사항을 제공하거나, 지시사항과 시작 단어를 함께 사용하는 등의 방법을 사용하세요. 작동하는지 확인하기 위해 반복적으로 검증하세요.         |
| 순서가 중요합니다                         | 모델에 정보를 제공하는 순서는 출력에 영향을 줄 수 있습니다. 최근성 편향을 통해 학습 예제에서도 다른 옵션을 시도해보세요.                                                                                           |
| 모델에 "탈출구"를 제공하기                | 모델이 작업을 완료할 수 없는 경우 제공할 수 있는 _대체_ 완성 응답을 제공하세요. 이렇게 하면 모델이 잘못된 또는 가짜 응답을 생성할 가능성이 줄어듭니다.                                                             |
|                                           |                                                                                                                                                                                                                    |

모든 모범 사례와 마찬가지로, 모델, 작업 및 도메인에 따라 _결과가 달라질 수 있습니다._ 이를 시작점으로 사용하고, 가장 잘 작동하는 방법을 찾기 위해 반복적으로 개선하세요. 새로운 모델과 도구가 사용 가능해질 때마다 프롬프트 엔지니어링 프로세스를 지속적으로 재평가하고, 프로세스의 확장성과 응답 품질에 초점을 맞추세요.

<!--
LESSON TEMPLATE:
This unit should provide a code challenge if applicable

CHALLENGE:
Link to a Jupyter Notebook with only the code comments in the instructions (code sections are empty).

SOLUTION:
Link to a copy of that Notebook with the prompts filled in and run, showing what one example could be.
-->

## 과제

축하합니다! 레슨의 끝까지 도달했습니다! 이제 실제 예제를 사용하여 몇 가지 개념과 기법을 테스트해 보는 시간입니다!

과제를 위해 상호작용적으로 완료할 수 있는 Jupyter Notebook을 사용할 것입니다. 또한 아이디어와 기법을 탐색하기 위해 자체적으로 Markdown 및 Code 셀을 추가하여 Notebook을 확장할 수도 있습니다.

### 시작하기 전에, 레포지토리를 포크한 다음

- (권장) GitHub Codespaces를 시작하세요.
- (대안) 레포지토리를 로컬 장치에 복제하고 Docker Desktop을 사용하세요.
- (대안) 선호하는 Notebook 실행 환경에서 Notebook을 열어보세요.

### 다음으로, 환경 변수를 구성하세요

- 레포지토리 루트에 있는 `.env.copy` 파일을 `.env`로 복사하고 `AZURE_OPENAI_KEY`, `AZURE_OPENAI_ENDPOINT`, `AZURE_OPENAI_DEPLOYMENT` 값을 채워넣으세요. [Learning Sandbox section](./04-prompt-engineering-fundamentals#learning-sandbox)에서 자세한 내용을 확인하세요.

### 다음으로, Jupyter Notebook을 열어보세요

- 런타임 커널을 선택하세요. 옵션 1 또는 2를 사용하는 경우, 개발 컨테이너에서 제공하는 기본 Python 3.10.x 커널을 선택하면 됩니다.

이제 연습문제를 실행할 준비가 되었습니다. 여기서는 *정답과 오답*이 없습니다. 대신, 시행착오를 통해 옵션을 탐색하고, 주어진 모델과 응용 프로그램 도메인에 대한 직관을 구축하는 것입니다.

_이러한 이유로 이 레슨에는 코드 솔루션 세그먼트가 없습니다. 대신, 노트북에는 "My Solution:"이라는 제목의 Markdown 셀이 있어 참고용으로 한 가지 예시 출력을 보여줍니다._

 <!--
LESSON TEMPLATE:
Wrap the section with a summary and resources for self-guided learning.
-->

## 지식 확인

다음 중 합리적인 모범 사례를 따르는 좋은 프롬프트는 무엇입니까?

1. 빨간색 차의 이미지를 보여주세요.
2. 일몰이 진 절벽 옆에 주차된 볼보 제조사와 모델이 XC90인 빨간색 차의 이미지를 보여주세요.
3. 볼보 제조사와 모델이 XC90인 빨간색 차의 이미지를 보여주세요.

A: 2번입니다. 이 프롬프트는 "무엇"에 대한 세부 정보를 제공하며 (어떤 차가 아니라 특정 제조사와 모델의 차), 전반적인 설정에 대한 설명도 포함하고 있습니다. 3번은 두 번째로 좋은 프롬프트입니다. 많은 설명이 포함되어 있습니다.

## 🚀 도전과제

프롬프트 "볼보 제조사와 빨간색 차의 이미지를 보여주세요"를 "단서" 기법과 함께 활용해보세요. 어떤 응답이 나오고, 어떻게 개선할 수 있을까요?

## 훌륭합니다! 계속해서 학습하세요

5번 레슨으로 이동하여 [고급 프롬프트 생성](../../../05-advanced-prompts/translations/ko/README.md?WT.mc_id=academic-105485-koreyst)을 살펴보세요!
